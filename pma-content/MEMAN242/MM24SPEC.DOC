File : MM24SPEC.TXT
Datum: 19 september 1992
Door : Ries Vriend / Ramon van der Winkel - (c) MST
---------------------------------------------------

Deze tekst bevat de informatie die nodig is voor het schrijven van
MemMan 2.4 toepassingsprogramma's. Voor specifieke specificaties
omtrend het programmeren van TSR's wordt echter verwezen naar de
technische documentie die te vinden is op de `TSR-Development disk'.
Hierop staan de volledige TSR specificaties en enkele TSR ontwikkel
tools. Deze disk kan besteld worden bij het MST, zie voor meer
informatie hierover de LezersService van MSX Computer Magazine.


Inhoud
------

Wijzigingen in MemMan 2.3 ten opzichte van versie 2.2
Updates van MemMan 2.30 naar MemMan 2.31
Wijzigingen in MemMan 2.4 ten opzichte van versie 2.3

Waarom MemMan 2.4?

De principes

Appendix 1: BIOS aanroepen onder Turbo Pascal
Appendix 2: Tips en aanwijzingen voor programmeurs


MEMMAN versie 2.4 - specificaties
=================================

Wijzigingen in MemMan 2.3 ten opzichte van versie 2.2:
-----------------------------------------------------

-      De functie XTsrCall (61) is toegevoegd. Deze functie werkt
       identiek aan de functie TsrCall (63), het Tsr-ID wordt echter
       verwacht in register IX in plaats van BC. Hierdoor komt
       register BC vrij om als invoerparameter gebruikt te worden.

-      Door middel van de functie Info (50) kan het adres worden
       opgevraagd waarop XTsrCall rechtstreeks kan worden aangeroe-
       pen.

-      De funtie status (31) is verbeterd. De totale hoeveelheid
       bruikbaar werkgeheugen in de computer wordt nu correct gemeld,
       ook onder MSX-DOS2.

-      De Alloc (10) functie herkent nu ook geheugen dat beschikbaar
       komt wanneer de DOS2 RAMdisk wordt verwijderd of verkleind!
       Het maakt daarbij niet meer uit of de RAMdisk wordt aangemaakt
       voor- of nadat MemMan werd ge‹nstalleerd.

-      De interne stack van MemMan die gebruikt wordt om functie-
       aanroepen te verwerken is vergroot tot 240 bytes, in plaats
       van 160. In de praktijk bleek dat de functiestack van MemMan
       2.2 te krap was om geneste "tsrCalls" te verwerken.


Updates van MemMan 2.30 naar MemMan 2.31:
----------------------------------------

-      Er bleek een bug te zitten in TL.COM, waardoor het inladen
       van TSR's onder DOS1 niet goed ging. De fout zat in het parsen
       van de command line, en was daags na de beurs bekend en
       opgelost. Patches zijn gepubliceerd in MSX Computer Magazine
       nummer 49 pagina 66 en MSX Club Magazine 38 pagina 56 en PTC
       Print nummer 59 pagina 7.

-      De tweede bug was complexer, en kwam aan het licht tijdens
       experimenten met nieuwe TSR's. Hij was nog niet eerder gemeld.
       Het ging om CMD TL. Dat commando voerde geen IniChk uit,
       waardoor de CurSeg functie van MemMan ook nog niet goed
       werkte. TSR's die CurSeg gebruikten en geheugen schakelden in
       pagina 2 liepen daardoor vast. Dat was (is?) op dat moment
       alleen de printerbuffer PB.TSR. Bij het laden van een TSR met
       TL.COM ging het wel goed, die doet namelijk wel een IniChk.
       Ook deze bug is opgelost met een patch, gepubliceerd in MSX
       Computer Magazine 52 pagina 21 en MSX Club Magazine 40 pagina
       89 en PTC Print nummer 59 pagina 7.


Wijzigingen in MemMan 2.4 ten opzichte van versie 2.3:
-----------------------------------------------------

-      De GetTPA (33) functie is toegevoegd, zodat het nu ook onder
       Disk BASIC mogelijk is de 32 kB RAM `achter' het BIOS en het
       BASIC ROM te gebruiken. Veel mensen hebben hierom gevraagd!

-      CMD HELP wordt nu ondersteund door de standaard TSR `MST
       TsrUtils'. Met dit commando kan een kort overzicht van de
       extra BASIC commando's op het scherm gezet worden. Zie voor
       meer informatie over CMD HELP de tips en aanwijzingen voor
       programmeurs.

-      TL.COM maakt nu onder DOS 2 gebruik van het Environment Item
       TL, om te achterhalen waar de TSR's staan. Harddisk bezitters
       hoeven slechts een `SET TL=A:\TSRS' in hun AUTOEXEC.BAT op te
       nemen en alle TSR's in de subdirectory A:\TSRS zijn ten aller
       tijd bereikbaar voor TL. Het opgeven van een pad is dan niet
       meer nodig.

-      TV.COM laat nu ook zien in welk segment de verschillende
       TSR's zitten. Hierdoor is het eenvoudig mogelijk een extra
       segment vrij te maken door de TSR's die er in zitten te
       verwijderen. TSR segment 0 is het MemMan segment, het geheugen
       dat in dat segment nog vrij is kan niet door andere program-
       ma's maar alleen door TSR's gebruikt worden.

-      Er zijn twee functies toegevoegd voor het uitlezen en instel-
       len van de stack pointer van MemMan's interne stack. Dat is
       nodig als een programma de Expressie evaluator in het BASIC
       ROM aanroept en fouten zelf wil afhandelen. Het kan dan
       namelijk zijn dat de ExpEval een TSR aanroept, die zelf weer
       ExpEval aanroept en er op dat moment een fout optreedt. Dan
       blijft er rotzooi op de MemMan stack achter. Als na dergelijke
       fouten de errorhandler van MSX BASIC gebruikt wordt is er
       niets aan de hand: dan maakt MemMan zijn stack zelf schoon.

-      In elk TSR segment begint op adres &h4002 de MemMan functie
       afhandelings routine. MemMan aanroepen uit een TSR kan dus
       voortaan eenvoudig en snel met een `CALL &h4002'

-      Er wordt een nieuwe versie (1.04) van de bestandskopieerder
       BK meegeleverd die geen fouten maakt als er meer dan 4 MB
       geheugen beschikbaar is. In versie 1.02 liep een tellertje
       over waardoor de hoeveelheid geheugen onjuist op het scherm
       werd aangegeven.

-      IniChk geeft in HL nu het adres van de MemMan functieafhan-
       delingsroutine terug. Die hoeft dus niet apart via de Info
       functie opgevraagd te worden.


Waarom MemMan 2.4?
-----------------

In feite is er na de updates van MemMan 2.30 weinig reden geweest
tot het uitbrengen van een volgende versie. De verschillen tussen
2.3 en 2.4 zijn dan ook klein. Alle bekende bugs waren al verbeterd,
en grote uitbreidingen zijn er niet. Het is dus gebleven bij de een
aantal kleine extra's.
Naast wat er nu nieuw is hadden en hebben we nog meer en grotere
plannen. Daar wordt nog steeds aan gewerkt, maar we willen niet
wachten tot die goed uitgewerkt en vooral getest zijn met het uit-
brengen van 2.4. Dat doen we met name omdat er de laatste tijd meer
en meer programmeurs tegen een ontwerpfout in MemMan opgelopen zijn:
het was namelijk onmogelijk om de 32 kB RAM achter het ROM vanuit
Disk BASIC door middel van MemMan in te schakelen. Dat is nu opge-
lost: voortaan kan al het schakelwerk netjes via MemMan gebeuren, ook
als een programma onder Disk BASIC draait en echt al het geheugen tot
zijn beschikking wil hebben.
Alle andere uitbreidingen zijn leuk en aardig, maar hadden ook kunnen
wachten. Bovendien zitten er in de verdere plannen ook wat wensen en
verlangens die in feite behoorlijk belangrijk zijn. Stuk voor stuk
vereisen die echter een flinke verbouwing van de interne structuur
van MemMan en dat kost nu eenmaal tijd.


Gebruikte terminologie
----------------------

Segment      Geheugenblok van 16kB. Segmenten komen voor in Pagina
             specifieke segmenten (PSEG) en Flexibele segmenten
             (FSEG). De Flexibele segmenten kunnen op de pagina's 0,
             1 en 2 worden aangeschakeld. De Pagina specifieke
             segmenten alleen op hun eigen pagina. Er zijn drie
             soorten pagina specifieke segment: PSEG0000, PSEG4000
             en PSEG8000. Ze zijn op respectievelijk pagina 0,1 en 2
             aanschakelbaar.

Heap         Stuk geheugen in pagina 3 (ergens tussen &hC000 en
             &hFFFF) waarvan MemMan toepassingsprogramma's een stuk
             aan kunnen vragen en daarna vrij mogen gebruiken. De
             grootte ervan kan met behulp van het configuratiepro-
             gramma CFGMMAN ingesteld worden.

FastUse      Zelfde als Use, maar dan het adres waarop de routine
             direct aan te roepen is in pagina 3. Ook een aantal
             andere routines kunnen direct aangeroepen worden, wat de
             snelheid ten goede komt.

UnCrash      Om te voorkomen dat segmenten aangevraagd zijn en door
             een crash van een programma nooit meer vrij zouden
             worden gegeven, voert de IniChk routine een unCrash
             uit. Hierbij worden alle segmenten weer vrijgegeven.
             Het unCrashen van een segment is te voorkomen door een
             segment de Reserved status te geven. Dit kan met de
             functie SetRes (11). Normaal gesproken hoeft een segment
             niet de Reserved status gegeven te worden.

TPA          `Transient Program Area'. Oorspronkelijk werd hiermee
             onder CP/M en dus MSX DOS het stuk geheugen tussen
             adres &h0100 en de eerste byte van het operating systeem
             bedoeld. In dat gebied konden gebruikersprogramma's
             geladen worden. In deze tekst bedoelen we met TPA de
             vier segmenten (64 kB) die ingeschakeld zijn onder MSX
             DOS. De bovenste twee daarvan zijn ook ingeschakeld
             onder MSX BASIC.


De principes
------------

MemMan verdeelt het aanwezige geheugen in segmenten van 16 kB.
Voordat een segment gebruikt mag worden moet het worden aangevraagd.
Na gebruik dient het weer te worden vrijgegeven. Er zijn twee soorten
segmenten: de zogenaamde pagina-specifieke ofwel PSEG's en de flexib-
ele FSEG's.

PSEG's zijn segmenten die aangevraagd worden voor het gebruik op een
bepaalde pagina, bijvoorbeeld van &h4000-&h7FFF of van &h8000-&hBFFF.
Wanneer er een PSEG aangevraagd wordt zal MemMan zo mogelijk geheu-
gensegmenten toewijzen die niet in een memory-mapper zitten. FSEG's
zijn segmenten die op elke willekeurige pagina kunnen worden inge-
schakeld. Deze segmenten komen altijd uit memory mappers.

Welk soort segment er ook aangevraagd wordt, MemMan zal een 16-bits
`segmentcode' teruggeven. Deze segmentcode is weer nodig bij het
inschakelen of het weer vrijgeven van het segment. Wie alleen maar
geheugen nodig heeft in het gebied van &h8000 tot &hBFFF kan dus het
beste PSEG's aanvragen. MemMan gebruikt dan eerst zoveel mogelijk
geheugen uit de `oude' 16- en 64 Kb modules en gaat dan de mapper
gebruiken.

Met behulp van MemMan hoeft er dus nooit meer naar geheugen gezocht
te worden. Simpelweg een pagina aanvragen, gebruiken en uiteindelijk
weer vrijgeven. Zo eenvoudig is dat.
Overigens is er een pagina die zich met MemMan niet laat schakelen.
Pagina 3 bevat behalve de MemMan code zelf ook de stack (meestal) en
een grote hoeveelheid systeemvariabelen. Er zitten nogal wat haken en
ogen aan het wegschakelen van dat alles.


Functieomschrijving MemMan 2.4
------------------------------

MemMan functies kunnen worden uitgevoerd door een aanroep van de
`Extended BIOS' of EXTBIO hook, op adres &hFFCA. Het device ID van
MemMan - `M' oftewel &h4D - moet in register D worden geplaatst.
Register E dient het MemMan functienummer te bevatten. Na aanroep van
een MemMan functie kunnen alle registers gewijzigd zijn, behalve
indien het tegendeel wordt vermeld bij de functie-omschrijving.

Het is ook mogelijk MemMan direct aan te roepen, het adres waarop
dat kan gebeuren kan opgevraagd worden via de Info functie (50) en
wordt ook teruggegeven door IniChk (30) Op die manier worden de
nadelen van het aanroepen van MemMan via de hook omzeild. Zie voor
meer informatie de tips en aanwijzingen voor programmeurs.

De interruptstand blijft na een MemMan functie-aanroep in meeste
gevallen ongewijzigd. Sommige functies zoals de diverse (Fast)Use
functies schakelen de interrupts echter uit. Wanneer een MemMan
functie werd aangeroepen met de interrupts uit, zal MemMan nooit
terugkeren met de interrupts ingeschakeld.
Deze eigenschap is bijvoorbeeld van belang voor TSR programma's die
slechts een zeer kleine stack ter beschikking hebben. Zo lang de
interrupts uit staan, kunnen alle MemMan functies zonder problemen
worden uitgevoerd, mits de functie verwerkingsroutine van MemMan
rechtstreeks wordt aangeroepen. Wanneer de interrupts echter aan
staan is een grote stack vereist, omdat de interrupt-verwerkingsrou-
tine enkele tientallen bytes op de stack plaatst.


Naam:        Use0
Nummer:      0
Functie:     Aanschakelen van een segment op pagina 0 (adresgebied
             &h0000..&h3FFF)
In:          HL           = Segmentcode
Uit:         A            = Resultaatcode (-1 = Mislukt, 0 = Gelukt)

             Het inschakelen van een segment in pagina 0 is alleen
             mogelijk indien het segment de MSX-standaard slot-
             schakel entry points bevat.

Opm:         Deze functie mag niet worden aangeroepen via de EXTBIO
             hook. Deze functie mag alleen worden uitgevoerd door
             een rechtstreekse aanroep van de MemMan functie afhande-
             lingsroutine of de FastUse0 functie. De adressen waarop
             deze routines aangeroepen kunnen worden, kunnen via de
             info functie (50) worden verkregen.


Naam:        Use1
Nummer:      1
Functie:     Aanschakelen van een segment op pagina 1 (adresgebied
             &h4000..&h7FFF)
In:          HL           = Segmentcode
Uit:         A            = Resultaatcode (-1 = Mislukt, 0 = Gelukt)

Opm:         Deze functie mag niet worden aangeroepen via de EXTBIO
             hook. Deze functie mag alleen worden uitgevoerd door
             een rechtstreekse aanroep van de MemMan functie afhande-
             lingsroutine of de FastUse1 functie. De adressen waarop
             deze routines aangeroepen kunnen worden, kunnen via de
             info functie (50) worden verkregen.


Naam:        Use2
Nummer:      2
Functie:     Aanschakelen van een segment op pagina 2 (adresgebied
             &h8000..&hBFFF)
In:          HL           = Segmentcode
Uit:         A            = Resultaatcode (-1 = Mislukt, 0 = Gelukt)

Opm:         Deze functie mag niet worden aangeroepen via de EXTBIO
             hook. Deze functie mag alleen worden uitgevoerd door
             een rechtstreekse aanroep van de MemMan functie afhande-
             lingsroutine of de FastUse2 functie. De adressen waarop
             deze routines aangeroepen kunnen worden, kunnen via de
             info functie (50) worden verkregen.


Naam:        Alloc
Nummer:      10
Functie:     Aanvragen van een segment
In:          B            = Segment voorkeuze code
             Bit 0 en 1:  00 = PSEG0000
                          01 = PSEG4000
                          10 = PSEG8000
                          11 = FSEG
             Bit 2 tot 5: Ongebruikt. Moeten 0 zijn.
             Bit 6:       1 = Prefereer TPA oftewel het standaard
                          MSXDOS RAM slot. Dit resulteerd in sneller
                          schakelen, maar waarschijnlijk niet samen-
                          werken met niet-MemMan TSR's die zelf al in
                          het TPA slot gaan zitten.
             Bit 7:       1 = Prefereer ongeexpandeerd (dus snel)
                          slot. Hiervoor geldt hetzelfde als bij bit
                          zes. Ongeexpandeerde sloten schakelen
                          sneller, maar hebben een grotere kans al
                          in gebruik zijn door niet-MemMan toepas-
                          singen.
Uit:         HL           = Segmentcode. (&h0000 = Geen segment meer
                            vrij)
             B            = Segmentsoort code (-1 = FSeg, 0 = PSeg)

             Mocht een PSEG type aangevraagd, maar niet beschikbaar
             zijn wordt - indien mogelijk - een FSEG ter beschikking
             gesteld die dan het PSEG kan vervangen.


Naam:        SetRes
Nummer:      11
Functie:     Segment de Reserved status geven
In:          HL           = Segmentcode

             Geeft een segment de `Reserved-status'; zodat het
             segment niet automatisch wordt vrij gegeven na aanroep
             van de IniChk routine. Normaal gesproken hoeven program-
             ma's de reserved status niet te zetten, behalve als een
             programma - bijvoorbeeld een Ramdisk - een segment voor
             eigen gebruik zeker wil stellen.


Naam:        DeAlloc
Nummer:      20
Functie:     Teruggeven van een segment
In:          HL           = Segmentcode

             Bij het verlaten van een programma dient deze functie
             gebruikt te worden om alle aangevraagde segmenten weer
             terug te geven aan MemMan. De eventuele reserved status
             van het terug te geven segment wordt door DeAlloc
             automatisch opgeheven.
             Segmenten die ook door DOS2 beheerd worden, worden door
             de DeAlloc functie weer ter beschikking gesteld van
             DOS2.


Naam:        ClrRes
Nummer:      21
Functie:     Reserved status van het segment opheffen
In:          HL           = Segmentcode

             Het is niet nodig deze functie vlak voor DeAlloc aan te
             roepen. DeAlloc heft zelf de Reserved status van het
             segment op.


Naam:        IniChk
Nummer:      30
Functie:     Initialisatie MemMan voor een programma
In:          A            = Controle code
Uit:         A            = Controle code + "M"
             DE           = Versie nummer (format: Versie #D.E)
             HL           = Vanaf versie 2.4: adres MemMan functie-
                            afhandelings routine (Zie Info (50) voor
                            meer informatie)

             Deze routine telt de ASCII-waarde van de letter "M" op
             bij de inhoud van register A. Hierdoor kan er een MemMan
             aanwezigheids controle uitgevoerd worden. Verder wordt
             er een unCrash uitgevoerd en worden de segmentcodes van
             de actief aangeschakelde sloten berekend en opgeslagen
             voor CurSeg.
             De IniChk functie mag slechts ‚‚n keer door ieder MemMan
             toepassings programma aangeroepen worden. Dit aanroepen
             van IniChk dient te gebeuren voordat de overige functies
             van MemMan aangroepen worden. TSR programma's mogen de
             IniChk functie nooit aanroepen.


Naam:        Status
Nummer:      31
Functie:     Status gegevens van MemMan ophalen
Uit:         HL           = Aantal aanwezige segmenten
             BC           = Aantal nog vrije segmenten
             DE           = Aantal segmenten in dubbel beheer bij
                            DOS2 en MemMan
             A            = Connected Status van de aangesloten
                            hardware.
                            Bit 0: 1 indien DOS2 Mapper Support
                            Routines aanwezig, anders 0
                            Bit 1-7: Gereserveerd, altijd 0.

             Als bit 0 van de Connected status gezet is, zijn de
             geheugenbeheer functies van DOS 2.20 aanwezig.
             Het aantal nog vrije segmenten kan lager zijn dan is
             aangegeven in register BC, omdat sommige segmenten na
             de installatie van MemMan door DOS2 gebruikt zijn - om
             bijvoorbeeld een ramdisk te installeren.


Naam:        CurSeg
Nummer:      32
Functie:     Segmentcode van een aangeschakeld segment opvragen.
In:          B            = Paginanummer (0,1,2,3)
Uit:         HL           = Segmentcode
             A            = Segmentsoort code (255 = FSeg, 0 = Pseg)

             Deze routine geeft de huidige segmentcode terug van een
             van de vier pagina's.
             TSR programma's mogen deze functie niet gebruiken om
             het actieve segment in geheugen pagina 0 te bepalen. Om
             tijd te sparen wordt deze stand niet automatisch bepaald
             en opgeslagen bij de aanroep van een TSR. De actieve
             segmenten in de pagina's 1 en 2 worden echter bij iedere
             hook-aanroep opnieuw bepaald en kunnen ten alle tijde
             via deze functie opgevraagd worden. Omdat in pagina 3
             altijd hetzelfde segment actief is, is ook de segmentco-
             de van pagina 3 altijd opvraagbaar.
             Een snellere variant van deze functie is FastCurSeg
             routine. gebruikt. Het adres waarop deze routine aange-
             roepen kan worden is via de Info functie (50) op te
             vragen.


Naam:        GetTPA
Nummer:      33
Functie:     Segmentcode van een TPA segment opvragen.
In:          B            = Paginanummer (0,1,2,3)
Uit:         HL           = Segmentcode
             A            = Segmentsoort code (255 = FSeg, 0 = Pseg)

             Deze functie dient op vanuit een programma onder Disk
             BASIC toch de `onderste' 32 kB van het TPA aan te kunnen
             spreken. MemMan laat die twee segmenten normaal gespro-
             ken ongemoeid, omdat er wel eens RAMcartridges in zouden
             kunnen zitten, of bijvoorbeeld BASIC's RAMdisk. Gebruik
             ervan is dus op eigen risico. Controleer indien nodig
             wel of het om FSegs gaat!


Naam:        StoSeg
Nummer:      40
Functie:     Huidige segmenten stand opslaan
In:          HL           = Buffer adres (9 bytes groot)

             De voor MemMan bekende segmentcodes van de actief
             aangeschakelde sloten worden opgeslagen in het buffer.
             Deze segmentcodes zijn in beginsel door IniChk berekend
             en later door de Use functies geupdate. De opgeslagen
             stand is niet de huidige stand, maar de voor MemMan
             bekende stand. TSR kunnen hiermee dus niet de actieve
             stand opslaan.

Opm:         Deze functie mag niet worden aangeroepen via de EXTBIO
             hook. Deze functie mag alleen worden uitgevoerd door
             een rechtstreekse aanroep van de MemMan functie afhande-
             lingsroutine. Het adres waarop deze routine aangeroepen
             kan worden, kan via de info functie (50) worden verkre-
             gen.
             Natuurlijk kunnen ook de (Fast)CurSeg functies gebruikt
             worden om de momentele segment-stand op te vragen.


Naam:        RstSeg
Nummer:      41
Functie:     Opgeslagen segment-stand actief maken
In:          HL           = Buffer adres

             De in het buffer opgeslagen segment-stand wordt weer
             actief gemaakt en wordt opgeslagen voor CurSeg.

Opm:         Deze functie mag niet worden aangeroepen via de EXTBIO
             hook. Deze functie mag alleen worden uitgevoerd door
             een rechtstreekse aanroep van de MemMan functie afhande-
             lingsroutine. Het adres waarop deze routine aangeroepen
             kan worden, kan via de info functie (50) worden verkre-
             gen.
             Natuurlijk kunnen ook de (Fast)Use functies gebruikt
             worden om een segment-stand te herstellen.


Naam:        Info
Nummer:      50
Functie:     Geeft informatie over onder andere aanroep-adressen van
             MemMan functies
In:          B            = Informatie nummer (0..8)
Uit:         HL           = Informatie

             Informatie nummer overzicht. Tussen haakjes staan de
             equivalente MemMan functie codes:
             0 - Aanroepadres van FastUse0 (functie 0)
             1 - Aanroepadres van FastUse1 (functie 1)
             2 - Aanroepadres van FastUse2 (functie 2)
             3 - Aanroepadres van TsrCall (functie 63)
             4 - Aanroepadres van BasicCall
             5 - Aanroepadres van FastCurSeg (functie 32)
             6 - Aanroepadres van MemMan, de functie-afhandelings-
             routine
             7 - Versienummer van MemMan, format: Versie #H.L
             8 - Aanroepadres van XTsrCall (functie 61)
             9 - Aanroepadres van GetMMSP
             10 - Aanroepadres van SetMMSP

             De bovengenoemde functie-adressen mogen door een toe-
             passingsprogramma of TSR rechtstreeks aangeroepen
             worden. Alle entry adressen liggen gegarandeerd in
             pagina 3.
             De functies worden snel uitgevoerd omdat de MemMan CALL
             naar de EXTBIO hook vervalt en de functie-codes in
             registers D en E niet uitgeplozen hoeven worden. Een
             ander voordeel is dat parameters ook via het register DE
             doorgegeven kunnen worden, dit is vooral van belang bij
             de TsrCall en BasicCall functies.
             Bijvoorbeeld, de initialisatie routine van een TSR kan
             de benodigde functieadressen via de INFO functie opvra-
             gen en deze vervolgens voor later gebruik in de TSR
             programmacode opslaan, wat de snelheid van het TSR
             programma zeer ten goede kan komen.
             Een exacte beschrijving van de bovenstaande functies
             kan gevonden worden bij de MemMan functie waarvan het
             nummer tussen haakjes is aangegeven.
             Houd echter onder de aandacht dat de `snelle' functies
             op de volgende punten van de gewone MemMan functies
             verschillen:

fastUse?:    Schakelt een segment in in een bepaalde geheugen pagina.
             Zie de omschrijving bij de memMan `Use' functies.

tsrCall:     Register [DE] wordt ongewijzigd aan de TSR doorgegeven.
             Dit in tegenstelling tot functie 63 (TsrCall), register
             DE is dan al bezet om het MemMan functienummer in op te
             slaan.

xTsrCall:    Alle mainregisters (AF,HL,BC,DE) worden ongewijzigd aan
             de TSR doorgegeven. De TSR-ID code dient in register IX
             te worden geplaatst.

basicCall:   Heeft geen MemMan functie nummer.
Functie:     Aanroepen van een routine in de BASIC ROM.
In:          IX           = Call address in pagina 0 of 1
             AF,HL,BC,DE  = dataregisters voor de BASIC-ROM
Uit:         AF,HL,BC,E   = dataregisters van de BASIC-ROM
                          Interrupts disabled

             Via deze functie kunnen TSR's een routine aanroepen die
             zich in pagina 0 en/of pagina 1 van het BASIC-ROM
             bevindt. De bios moet al in pagina 0 aangeschakeld
             zijn. In pagina 1 wordt de BASIC ROM door MemMan aange-
             schakeld.
             Dit is bijvoorbeeld noodzakelijk om de math-pack rou-
             tines aan te kunnen roepen die in pagina 0 van de BASIC
             ROM zitten, maar tussendoor ook een aantal routines in
             pagina 1 aanroepen.
             De H.STKE (stack error) hook wordt afgebogen, zodat na
             een eventueel op getreden BASIC error de interne stacks
             van MemMan gereset kunnen worden.

fastCurSeg:  In register [A] komt geen zinnige waarde terug. De
             MemMan CurSeg functie (32) geeft aan of het een FSEG/-
             PSEG betreft.

memMan:      Heeft geen MemMan functienummer
Functie:     Rechtstreeks aanroepen van een MemMan functie.
In:          E            = MemMan functienummer
             AF,HL,BC     = Dataregisters afhankelijk van de aan te
                            roepen functie.
Uit:         AF,HL,BC,DE  = dataregisters afhankelijk van de aan-
                            geroepen functie.

             Een aanroep van deze routine heeft hetzelfde effect als
             het aanroepen van een MemMan functie via de EXTBIO
             hook. Doordat echter de aanroep naar de EXTBIO hook
             vervalt, worden de overige uitbreidingen die aan deze
             hook gekoppeld zijn niet aangeroepen. Hierdoor blijft
             het stack gebruik beperkt en wordt de verwerkingssnel-
             heid verhoogd.

GetMMSP:     Heeft geen MemMan functienummer
Functie:     Opvragen adres interne MemMan Stack Pointer
In:          Niets
Uit:         HL           = Interne stackpointer van de TSR-Manager.

SetMMSP:     Heeft geen MemMan functienummer
Functie:     Instellen adres interne MemMan Stack Pointer
In:          HL           = Nieuwe waarde voor interne stackpointer
                            van de TSR-Manager.
Uit:         Niets

             TSR's kunnen met deze twee functies de interne stack
             pointer van MemMan opvragen, en weer herstellen wanneer
             een bepaalde TSR niet netjes is teruggekeerd naar het
             returnadres van de TSR-Manager. 
             Dat is bijvoorbeeld nodig als een programma de Expres-
             sie evaluator in het BASIC ROM aanroept en fouten zelf
             wil afhandelen. Het kan dan namelijk zijn dat de ExpEval
             een TSR aanroept, die zelf weer ExpEval aanroept en er
             op dat moment een fout optreedt. Dan blijft er rotzooi
             op de MemMan stack achter. Als na dergelijke fouten de
             errorhandler van MSX BASIC gebruikt wordt is er niets
             aan de hand: dan maakt MemMan zijn stack zelf schoon.

             Voorbeeld:
             ; Dit is een voorbeeld van een goede aanroep van de
             ; expressieevaluator in het BASIC ROM, zoals die in
             ; een programma voor kan komen.
             ...
             ld (saveSP),sp          ;Bewaar SP van TSR-programma
             call getMMSP
             ld (saveMMSP),hl        ;Bewaar SP van MemMan
             aanroep frmEval         ;Evalueer expressie (BIOS)
             ...
             jp main

             ; Deze routine hangt aan de H.ERRO
             ; wordt aangeroepen indien er een
             ; fout in de expressie zat
             ld sp,(saveSP)          ;Herstel de TSR-stack
             ld hl,(saveMMSP)
             call setMMSP            ;Herstel de MemMan stack
             jp main                 ;Doe alsof niets gebeurd is...


Naam:        XTsrCall
Nummer:      61
Functie:     Roep het driver-entry van een TSR aan
In:          IX           = ID code van de aan te roepen TSR
             AF,HL,BC,DE  = worden ongewijzigd doorgeven aan de TSR.
Uit:         AF,HL,BC,DE  = komen ongewijzigd terug van de TSR.

             Deze functie is een verbeterde versie van de functie
             TsrCall (63). Omdat met deze functie alle main-regis-
             ters aan de TSR kunnen worden doorgegeven, verdient het
             aanbeveling om deze functie te gebruiken in plaats van
             functie 63.

Opm:         Deze functie mag niet worden aangeroepen via de EXTBIO
             hook, omdat bij een aanroep via EXTBIO het IX-register
             verminkt wordt. Roep deze functie daarom rechtstreeks
             aan, of gebruik de MemMan functie-afhandelingsroutine.
             De adressen waarop deze routines aangeroepen kunnen
             worden, kunnen via de info functie (50) worden opge-
             vraagd.


Naam:        GetTsrID
Nummer:      62
Functie:     Bepaal TSR ID code
In:          HL           = Pointer naar de TsrNaam (12 tekens).
                            Ongebruikte posities opvullen met spa-
                            ties.
Uit:         Carry        = Clear (NC) als TSR gevonden is, Set (C)
                            als TSR niet gevonden is.
             BC           = TSR ID code


Naam:        TsrCall
Nummer:      63
Functie:     Roep het driver-entry van een TSR aan
In:          BC           = ID code van de aan te roepen TSR
             AF,HL,DE     = worden ongewijzigd doorgeven aan de TSR.
Uit:         AF,HL,BC,DE  = komen ongewijzigd terug van de TSR.

             Merk op dat alhoewel het DE register ongewijzigd aan de
             TSR wordt doorgegeven, het niet voor parameter-invoer
             benut kan worden. De Extended BIOS functiecode van
             MemMan (D='M' E=63) moet namelijk in dat register
             geplaatst worden.
             Bij de Fast-TsrCall routine treedt deze complicatie
             niet op; het adres van deze routine kan middels de info
             functie opgevraagd worden.


Naam:        HeapAlloc
Nummer:      70
Functie:     Alloceer ruimte in de heap
In:          HL           = Gewenste grootte van de ruimte (in bytes)
Uit:         HL           = &h0000 als er onvoldoende ruimte was,
                            anders het startadres van de ruimte.

             Door middel van deze functie kan een stuk geheugen
             gealloceerd worden. Het geheugenblok zal zich gegaran-
             deerd in pagina 3 bevinden.
             De heap is vooral nuttig voor TSR programma's, die hem
             bijvoorbeeld als tijdelijke of permanente diskbuffer
             kunnen gebruiken. Ook andere buffers - waarvan het
             absoluut noodzakelijk is dat ze zich in pagina 3 bevin-
             den - kunnen op de heap worden geplaatst.
             Aangevraagde blokken geheugen uit de heap blijven
             onbruikbaar voor andere programma's totdat een `Heap-
             DeAlloc' is uitgevoerd (functie 71).
             De grootte van de heap kan worden ingesteld door middel
             van het configuratie programma CFGMMAN.


Naam:        HeapDeAlloc
Nummer:      71
Functie:     Geef geAlloceerde ruimte van de heap weer vrij
In:          HL           = Startadres van de ruimte


Naam:        HeapMax
Nummer:      72
Functie:     Geef de lengte van het grootste vrije blok geheugen in
             de heap terug
Uit:         HL           = Lengte van het grootste vrije blok


Gebruik van de stack onder MemMan
---------------------------------

MemMan toepassingsprogramma's dienen de stack pointer (SP) bij
voorkeur in pagina 2 of 3 (tussen &h8000 en &hFFFF) te plaatsen.
Indien MemMan door een hook-aanroep geactiveerd wordt, wordt het
huidige segment in pagina 1 (&h4000 tot &h8000) namelijk weggescha-
keld om plaats te maken voor de TSR-Manager en de eventuele TSR's.
Indien de stack zich op dat moment in pagina 1 bevindt zal de compu-
ter vastlopen.

Indien TSR's na een BDOS call of interrupt via een BIOS-hook worden
aangeroepen treden geen stackproblemen op; ook niet indien de stack
van het toepassingsprogramma in pagina 1 staat. De BDOS en interrupt-
functies gebruiken namelijk hun eigen stack in pagina 3. De stack
bevindt zich dan alsnog in pagina 3 op het moment dat de hook aange-
roepen wordt.

Bestaande CP/M en MSX-DOS programmatuur is dus zonder problemen in
combinatie met MemMan 2 te gebruiken - maar alleen indien de stan-
daard BDOS calls gebruikt worden. Wanneer echter via een interslot
call een BIOS routine rechtstreeks aangeroepen wordt, dient de stack
in pagina 2 of 3 te staan. Reserveer in dat geval minimaal 150 bytes
voor de stack.


Appendix 1: BIOS aanroepen onder Turbo Pascal
---------------------------------------------

Indien in een Turbo Pascal programma interslot-calls naar de BIOS
gebruikt worden, is het belangrijk dat de stack in pagina 2 of 3
staat. Op het moment dat de BIOS dan een hook aanroept kan MemMan
veilig de TSR's aktiveren. De positie van de stack is afhankelijk
van het maximum programma adres dat tijdens de compilatie in Turbo
Pascal is ingesteld. De stack bevindt zich in Turbo Pascal direkt
onder het variabelen geheugen. Het variabelen geheugen dient bij
programma's die de BIOS aanroepen dus ruim boven adres &h8000 ge-
plaatst te worden.

Is geen source voorhanden, dan is het mogelijk om met een debugger
het stack adres van Turbo Pascal programma's aan te passen. De
initialisatie code van een TP programma ziet er als volgt uit:

  start: jp init
         ...
         ...
  init:  ld sp,100h
         ld hl,nn
         ld de,nn
         ld bc,nn
         call yy
         ld hl,nn
         ld de,stack    ;DE bevat het stack adres, hoeft
         ld bc,nn       ; alleen aangepast te worden als het
         call zz        ; lager is dan &h80A0
         ...

Het stackadres in register DE kan bijvoorbeeld op &hC100 gezet
worden.


Appendix 2: Tips en aanwijzingen voor programmeurs
--------------------------------------------------

Omdat de EXTBIO hook gebruikt wordt voor diverse systeem uitbrei-
dingen zoals Kanji en RS232 interfaces, is het mogelijk dat MemMan
functie-aanroepen bijzonder langzaam verwerkt worden. De prestaties
van de MemMan toepassingsprogramma's kunnen aanmerkelijk worden
verhoogd door functie afhandelingsroutine van MemMan rechtstreeks aan
te roepen, in plaats van de EXTBIO hook. Het adres waarop de functie
afhandelingsroutine aangeroepen kan worden, kan worden opgevraagd via
de info functie (50). Ook IniChk (30) geeft sinds versie 2.4 het
adres van de functieafhandelingsroutine in HL terug, zodat het meteen
in het programma ingevuld kan worden.

De meeste MemMan functies bevinden zich in een apart geheugensegment
in pagina 1. Deze functies schakelen over op een een interne stack,
waardoor MemMan toepassingsprogramma's met een betrekkelijk kleine
stack kunnen volstaan. Door een MemMan functie worden maximaal
twintig bytes op de stack van het toepassingsprogramma geplaatst. Dit
geldt echter alleen indien de functie rechtstreeks, of via de MemMan
functie-afhandelingsroutine wordt aangeroepen. Een functie-aanroep
via de EXTBIO hook kan echter een bijzonder grote stack vereisen. Dit
wordt veroorzaakt doordat alle uitbreidings-modules die aan de EXTBIO
hook gekoppeld zijn elkaar aanroepen, net zo lang totdat ‚‚n module
de functieaanroep herkent. Wanneer er tussendoor ook nog interrupts
afgehandeld worden, kan het stackgebruik sterk oplopen. Al met al kan
gesteld worden dat er bij een aanroep van de EXTBIO hook minimaal 150
bytes stackruimte beschikbaar moet zijn. Ook om deze reden is het
verstandig om de MemMan functie-afhandelingsroutine te gebruiken in
plaats van de EXTBIO hook.

MemMan versie 1.1 bevat nog een aantal bugs die in versie 2 opgelost
zijn. Het voordeel van MemMan 1.1 is echter dat er geen extra segment
gebruikt wordt, en het programma dus ook loopt op 64 kB computers.
Het is echter ondoenlijk om voor die beperkte groep MemMan 1.1 nog up
to date te houden. Om een programma ook op 64 kB computers te laten
werken adviseren wij dan ook wanneer MemMan niet aanwezig is zelf 64
kB RAM in te schakelen en te gebruiken, of eventueel zelfs de hele
mapper. Onder DOS is er om 64 kB RAM in te schakelen immers geen
MemMan nodig, en vanuit MSX Basic kan het met MemMan 1.1 toch niet
netjes. MemMan versie 1.1 zal niet verder ontwikkeld worden.

Bij het programmeren van TSR's kan sinds versie 2.4 gebruikt gemaakt
worden van de MemMan functie-afhandelingsroutine op adres &h4002, die
daar altijd staat als er een TSR-segment ingeschakeld is. dat maakt
de code in TSR's sneller en een stuk overzichtelijker!

Maak bij het schrijven van de VDP registers altijd gebruik van de
daarvoor bedoelde BIOS routines! Dan worden namelijk ook de systeem-
variabelen in pagina 3 bijgehouden, en sommige TSR's (CurBlink,
screendumpers, screensavers, debuggers, memory viewers) maken daar
gebruik van. Bijvoorbeeld om te achterhalen wel schermtype er op dit
moment actief is of waar de sprite-tabellen staan. Ook het beschrij-
ven van de palet-registers dient via de BIOS te gebeuren, zodat de
informatie in het VRAM ook bijgewerkt wordt. Alleen als dat VRAM
absoluut voor andere zaken nodig is (Bijvoorbeeld bij een VDP(24)
scroll) moet hiervan helaas afgeweken worden.

Zet de interupts uit bij het sturen van een blok data naar het VRAM.
Het is mogelijk dat een TSR die tussendoor actief wordt iets uit het
VRAM leest of er naar schrijft, en dan wordt de lees/schrijfpointer
van de VDP gewijzigd. Let er op dat sommige BIOS routines de inter-
rupts zelf aanzetten! In die gevallen kan er in het hoofdprogramma
(in TSR kan het ook, maar dan moet de toestand van het bit eerst
gelezen en bewaard worden) gebruik gemaakt worden van het Interupt
Enable bit in de VDP. Door die uit te zetten genereerd de VDP geen
interrupts meer. Een DI is nog steeds nodig, er zijn namelijk ook
cartridges die interrupts kunnen genereren, maar het is iets veili-
ger.

Het aanvragen van segmenten (ALLOC) uit een interrupt routine kan
tot het ophangen van de machine leiden. Dit omdat DOS2 niet reentrant
is. Als DOS2 actief is op moment dat een interrupt optreedt en uit de
interrupt routine wordt DOS2 nogmaals aangeroepen wordt onder andere
de interne stack van DOS2 overschreven. En ALLOC roept (als DOS2
aanwezig is) de DOS2 mapper support routines aan. Een goede en
afdoende oplossing voor dit probleem is nog niet bekend. Voor DEALLOC
geldt waarschijnlijk hetzelfde. USE, zo leert de ervaring met de
printerbuffer, levert geen enkel probleem op.

Laat programma's een vastgesteld maximum aantal segmenten aanvragen.
Er bestaan 4 MB Memory Mappers, en het is niet eens erg ingewikkeld
om acht van die dingen via twee slotexpanders op een MSX aan te
sluiten. Dat levert een totaal van meer dan 32 MB (2048 segmenten)
op. Meer segmenten aanvragen dan nodig is kost slechts nodeloos tijd
en ruimte. Overigens heeft bijvoorbeeld BK ook een grens, die vraagt
maximaal 4 MB aan. In versie 1.02 gaat het echter toch fout als die
4 MB ook daadwerkelijk beschikbaar blijkt te zijn... De oplossing is
in dat geval een voldoende grote RAMdisk of printerbuffer installe-
ren. De tekstverwerker TED doet het wel foutloos: die vraagt maximaal
2 MB aan bij MemMan.

Het is handig om TSR's die BASIC op de ‚‚n of andere manier uitbrei-
den te voorzien ook `CMD HELP' te laten herkennen en een kort over-
zicht van de mogelijkheden te laten afdrukken. Door de `QuitHook'
vlag bij het verlaten niet te zetten en de stack in tact te laten
worden ook de CMD HELPS's van andere TSR's (en uiteindelijk die van
`MST TsrUtils', die de foutmelding van BASIC onderdrukt) ook uitge-
voerd.

Vergeet nooit op de aanwezigheid en (ook in TSR's!) het versienummer
van MemMan te testen. Vereis minimaal 2.3(1), of beter nog: 2.4. Die
versie kan gewoon met het programma verspreid worden, dus een beper-
king hoeft dat niet te zijn.

Het is vaak makkelijk het huidige segment in pagina 2 en eventueel
(voor programma's onder Disk BASIC) de TPA segmenten 0 en 1, die
tegenwoordig met GetTPA achterhaald kunnen worden in de segmententa-
bel te zetten. Let er echter op het aanroepen van DeAlloc voor die
segmenten niet nodig is. MemMan controleert de aan DeAlloc aangeboden
segmentcodes namelijk niet en gaat fouten maken!


** Einde **
